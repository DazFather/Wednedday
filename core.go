package main

import (
	_ "embed"
	"encoding/json"
	"errors"
	"html/template"
	"io/fs"
	"net/url"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"
)

const (
	home = "home"

	homeFileName     = home + ".tmpl"
	appFileName      = "app" + COMPONENT_EXT
	settingsFileName = "wed-settings.json"
	scriptFileName   = "wed-utils.js"
	styleFileName    = "wed-style.css"
	composedFileName = "index.html"

	COMPONENT_EXT   = ".wed.html"
	COMPONENT_CLASS = "wed-component"
)

var (
	//go:embed resources/home.default.tmpl
	homeTemplateContent []byte
	//go:embed resources/app.default.wed.html
	appComponentContent []byte
	//go:embed resources/style.default.css
	defStyleContent []byte
	//go:embed resources/utils.default.js
	defScriptContent []byte
)

type Settings struct {
	HomeTempl string         `json:"HomeTempl,omitempty"`
	HomeDir   string         `json:"HomeDir,omitempty"`
	ScriptDir string         `json:"ScriptDir,omitempty"`
	StyleDir  string         `json:"StyleDir,omitempty"`
	Scripts   []string       `json:"Scripts,omitempty"`
	Styles    []string       `json:"Styles,omitempty"`
	Run       []string       `json:"Run,omitempty"`
	Var       map[string]any `json:"Var,omitempty"`

	wedScripts []wedScript
	wedStyles  []wedScript
	dynamics   map[string]string
	home       *template.Template
	funcs      template.FuncMap
}

func (s Settings) genDirs(mountDir string) (err error) {
	for _, dir := range slices.Compact([]string{s.ScriptDir, s.StyleDir}) {
		if err = os.MkdirAll(filepath.Join(mountDir, s.HomeDir, dir), 0750); err != nil {
			return
		}
	}
	return
}

func LoadSettings(fileName string) (s Settings, err error) {
	var content []byte

	switch fileName = filepath.Clean(fileName); fileName {
	case ".":
		fileName = settingsFileName
		fallthrough
	default:
		if content, err = os.ReadFile(fileName); err == nil {
			err = json.Unmarshal(content, &s)
		}
		if err != nil {
			err = errors.New(`Cannot load "` + fileName + `" as settings: ` + err.Error())
		}
	}

	s.HomeDir = filepath.Clean(s.HomeDir)
	s.ScriptDir = filepath.Clean(s.ScriptDir)
	s.StyleDir = filepath.Clean(s.StyleDir)
	if s.HomeTempl = filepath.Clean(s.HomeTempl); s.HomeTempl == "." {
		s.HomeTempl = homeFileName
	}

	s.dynamics = make(map[string]string)
	return
}

func genFile(force bool, content []byte, path ...string) (fileName string, err error) {
	fileName = filepath.Join(path...)

	switch filepath.Dir(fileName) {
	case ".", "":
		if wd, e := os.Getwd(); e == nil {
			fileName = filepath.Join(wd, fileName)
		}
	}

	if !force {
		if _, err = os.Stat(fileName); err == nil || !errors.Is(err, os.ErrNotExist) {
			return
		}
	}
	err = os.WriteFile(fileName, content, 0666)
	return
}

func Build(fromPath string, settings *Settings) (err error) {
	settings.funcs = template.FuncMap{
		"args":          func(v ...any) []any { return v },
		"importDynamic": settings.importDynamic,
	}

	var content []byte
	if content, err = os.ReadFile(filepath.Join(fromPath, settings.HomeTempl)); err == nil {
		settings.home, err = template.New(home).Funcs(settings.funcs).Parse(string(content))
	}
	if err != nil {
		settings.home = template.Must(template.New(home).Funcs(settings.funcs).Parse(string(homeTemplateContent)))
		warn(`Cannot use "`+settings.HomeTempl+`" as home template`, "Autogenerated default will be used. ", err)
	}

	err = filepath.Walk(filepath.Clean(fromPath), func(path string, info fs.FileInfo, e error) error {
		if e == nil && !info.IsDir() && strings.HasSuffix(info.Name(), COMPONENT_EXT) {
			e = settings.AddComponent(path)
		}
		return e
	})
	if err != nil {
		return
	}
	if err = settings.genResources(); err != nil {
		return
	}

	homePage, err := os.Create(filepath.Join(fromPath, settings.HomeDir, composedFileName))
	if err != nil {
		return
	}
	defer homePage.Close()

	t, err := settings.home.Clone()
	if err == nil {
		err = t.Execute(homePage, settings)
	}
	return
}

func (s Settings) link(dir ...string) string {
	var path = filepath.Join(dir...)
	if p, err := filepath.Rel(s.HomeDir, path); err == nil {
		path = p
	}

	return url.PathEscape(filepath.ToSlash(path))
}

func (s *Settings) AddComponent(fileName string) (err error) {
	rawcontent, err := os.ReadFile(fileName)
	if err != nil {
		return
	}

	_, name := filepath.Split(fileName)
	name = strings.TrimSuffix(name, COMPONENT_EXT)

	errch := make(chan error)
	go func() {
		var wg sync.WaitGroup
		wg.Add(3)

		go func() {
			defer wg.Done()
			if e := s.addJS(name, rawcontent); e != nil {
				errch <- e
			}
		}()

		go func() {
			defer wg.Done()
			if e := s.addCSS(name, rawcontent); e != nil {
				errch <- e
			}
		}()

		go func() {
			defer wg.Done()
			if e := s.addHTML(name, rawcontent); e != nil {
				errch <- e
			}
		}()

		wg.Wait()
		close(errch)
	}()

	i := 0
	for e := range errch {
		danger(e)
		i++
	}
	if i > 0 {
		err = errors.New(`Invalid definition of component "` + name + `"`)
	}

	return
}
